- ioc 和 aop
    - @Configuration 使用AnnotationConfigApplicationContext指定该注解所在的类，来创建applicationContext
    - @ComponentScan 扫描当前包和子包
    - @PropertySource 加载属性文件
    - 创建bean
        - @Bean，在Configuration类里创建 例如，使用@Bean创建DataSource
        - 自定义名称的bean：@Bean("名称")或者加@Qualifier("名称")
        - @Profile("test")修饰@Bean 如果启动时加上-Dspring.profiles.active=test,master，就会创建
        - @Component，标在类上
    - 注入：
        - 注入值：@Value("1") private String version; 
        - 注入其他bean的属性值：@Value("#{beanName.attr}")
        - 注入资源：@Value("classpath:资源文件") private Resource resource;
        - 注入Bean：@Autowired
        - 注入Collections：@Autowired，会把所有该类型的bean全部注入的集合中
    - bean初始化和结束
        - @PostConstruct 需要javax.annotation-api依赖 在创建完bean，注入完所有变量后执行
        - @PreDestroy 需要javax.annotation-api依赖
    - 条件装配  
        - @Conditional(Class<? extends Condition>[] value()) 当所有condition class的matches函数返回true，就创建
    - aop 
        - @EnableAspectJAutoProxy标注在@Configuration所在的类上，开启切面自动代理，会扫描带@Aspect的注解bean，并织入方法
        - @Aspect切面类
        - 切入点表达式
        - @Before @Around

- jdbcTemplate
    - 创建DateSource Bean
    - 创建JdbcTemplate Bean，需要注入DateSource Bean来创建
    - 创建PlatformTransactionManager Bean，需要注入DateSource Bean来创建DataSourceTransactionManager并返回
    - 启动声明式事务：在configuration上标注 @EnableTransactionManagement
        - 在业务类或者方法上加@Transactional
    - 在其他业务Component中注入JdbcTemplate
    - 使用JdbcTemplate
        - int jdbcTemplate.update("sql语句", @Nullable Object... args)
        - `T jdbcTemplate.execute(ConnectionCallback<T> action)`，通过dataSource.getConnection()获取连接后的回调
            - T execute(ConnectionCallback<T> action)
            - ConnectionCallback FunctionalInterface: T doInConnection(Connection con)
        - `T jdbcTemplate.execute(sql语句, PreparedStatementCallback<T> action)` 通过conn.prepareStatement 获取到ps后的回调
            - T execute(String sql, PreparedStatementCallback<T> action)
            - PreparedStatementCallback<T> FunctionalInterface: T doInPreparedStatement(PreparedStatement ps)
        - `T jdbcTemplate.queryForObject(sql语句, sql参数Object[], RowMapper<T> rowMapper)` 
            - T queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)
            - rowMapper FunctionalInterface: T mapRow(ResultSet rs, int rowNum) 
        - `List<T> jdbcTemplate.query(sql语句, sql参数Object[], RowMapper<T> rowMapper)`
            - List<T> queryForObject(String sql, @Nullable Object[] args, RowMapper<T> rowMapper)
            - rowMapper FunctionalInterface: T mapRow(ResultSet rs, int rowNum) 
        - 获取generated key
            - int jdbcTemplate.update(PreparedStatementCreator psc, KeyHolder generatedKeyHolder)
            - PreparedStatementCreator FunctionalInterface: PreparedStatement createPreparedStatement(Connection con)
        - 使用BeanPropertyRowMapper，传入bean class，直接创建一个rowMapper
    - 使用dao模式
        - JdbcDaoSupport需要jdbcDaoSupport.setJdbcTemplate，然后使用jdbcDaoSupport.getJdbcTemplate获取jdbcTemplate
        - 创建AbstractGeneric抽象模板类，继承JdbcDaoSupport，@PostConstruct里setJdbcTemplate，默认构造里初始化entityClass，
          rowMapper，table三个参数，entityClass代表继承AbstractGeneric类时，指定的泛型实体类。
        - 在AbstractGeneric抽象模板类里定义各个dao的通用方法，然后使用getJdbcTemplate().queryForObject，getJdbcTemplate().query
          getJdbcTemplate().deleteById做实际操作，传的sql里面的table名，rowMapper都是子类的实际值
        - 创建各个dao类bean，继承AbstractGeneric，并指定实体类T，创建bean时，就初始化了entityClass，rowMapper，table
    
- hibernate
    - 创建DateSource Bean
    - 创建LocalSessionFactoryBean Bean 需要注入DateSource Bean，指定entity实体类扫描路径，设置数据库方言，
      是否自动创建数据库表，show_sql等属性
    - 创建createHibernateTemplate Bean，需要注入LocalSessionFactoryBean， 也可以不创建，直接LocalSessionFactoryBean访问数据库
    - 创建PlatformTransactionManager Bean，需要注入LocalSessionFactoryBean来创建HibernateTransactionManager并返回
    - 启动声明式事务：在configuration上标注 @EnableTransactionManagement
        - 在业务类或者方法上加@Transactional
    - 创建实体类entity
        - @Entity表示实体类
        - @Column表示列，可以指定nullable，updatable，length，unique属性
        - @Table(name = "users")指定实体类对应的表
        - @Id
        - @GeneratedValue(strategy = GenerationType.IDENTITY)
        - @PrePersist持久化之前做的操作，用于设置CreatedAt
        - @MappedSuperclass：如果一个entity类要继承一个类，被继承的必须使用这个注解表示公共列
        - entity类上写 @NamedQueries @NameQuery定义查询语句
    - 使用hibernateTemplate
        - 在每个业务类中注入hibernateTemplate
        - entity load(entity.class, id)
        - entity get(entity.class, id)
        - List<entity> findByExample(entity)  null的属性不加条件，不空的属性就是where p1 = xxx and p2 = xxx
        - List<entity> findByCriteria(DetachedCriteria criteria)
            - criteria.add(Criterion criterion)
            - Restrictions.between(String propertyName, Object low, Object high)
            - Criterion Restrictions.eq(String propertyName, Object value)
            - 等等
            - Criterion Restrictions.and(Criterion criterion1, Criterion criterion2)
            - Criterion Restrictions.or(Criterion criterion1, Criterion criterion2)
        - save(entity)
        - delete(entity)
        - update(entity)
        - List<entity> find(String queryString, Object... values)
        - List<entity> findByNamedQuery(String queryName, Object... values)
    - 使用hibernate的sessionFactory访问
        - session = sessionFactory.getCurrentSession()
        - 省略。。。
    
    
- Jpa
    - 创建DateSource Bean
    - 创建LocalContainerEntityManagerFactoryBean Bean，需要注入DateSource Bean，指定entity实体类扫描路径，
      指定Jpa供应商vendorAdapter（例如hibernate实现了Jpa，就可以指定HibernateJpaVendorAdapter），数据库方言，
      是否自动创建数据库表，show_sql等属性，返回一个entityManagerFactoryBean
    - 创建PlatformTransactionManager Bean，需要注入EntityManagerFactory来创建JpaTransactionManager并返回
    - 启动声明式事务：在configuration上标注 @EnableTransactionManagement
        - 在业务类或者方法上加@Transactional
    - 创建实体类，和上面hibernate一模一样
    - LocalContainerEntityManagerFactoryBean的使用
        - 在每个业务类中注入EntityManager em
        - entity find(entity.class, id)
        - 使用Criteria构建query
            - CriteriaBuilder getCriteriaBuilder()
            - CriteriaQuery<entity> criteriaBuilder.createQuery(entity.class)
            - Root<entity>     criteriaQuery.from(entity.class)
            - CriteriaQuery<T> criteriaQuery.where(Expression<Boolean> restriction)
            - Predicate criteriaBuilder.equal(Expression<?> x, Expression<?> y)
                - Predicate extend Expression<Boolean>
            - Path root.get(String attributeName)
                - Path extends Expression
            - ParameterExpression criteriaBuilder.parameter(Class<T> paramClass, String name)
                - ParameterExpression extends Expression
            - TypedQuery<entity> em.createQuery(CriteriaQuery)
            - TypedQuery<entity> typedQuery.setParameter(String name, Object value)
            - List<entity> typedQuery.getResultList()
        - 直接使用HqlString构建query
            - TypedQuery<User> query = em.createQuery(String qlString, Class<entity> resultClass)
            - TypedQuery<entity> typedQuery.setParameter(String name, Object value)
            - List<entity> typedQuery.getResultList() 
        - 使用NamedQuery
            - TypedQuery<User> query = em.createNamedQuery(String name, Class<T> resultClass)
            - TypedQuery<entity> typedQuery.setParameter(String name, Object value)
            - List<entity> typedQuery.getResultList() 
        - em.persist(entity)
        - em.remove(entity)
        - em.refresh(entity)
        - em.merge(entity)
    
- myBatis
    - 创建DateSource Bean
    - 创建SqlSessionFactoryBean Bean，需要注入DataSource Bean来创建sqlSessionFactoryBean并返回
    - 创建PlatformTransactionManager Bean，需要注入DateSource Bean来创建DataSourceTransactionManager并返回
    - 启动声明式事务：在configuration上标注 @EnableTransactionManagement
        - 在业务类或者方法上加@Transactional
    - 在configuration类上使用@MapperScan("xxx")来指定mapper接口的扫描路径，mybatis会为这些接口创建代理实现类
    - 创建entityMapper接口，定义所有的数据库操作方法，并使用@select，@Insert，@Update，@Delete注解来标注每个方法对应的sql语句
        - 使用@Param来翻译参数名
    - 在业务方法内注入entityMapper Bean
    - 【注意】：如果把所有的sql语句都写在mapper.xml文件中，而不是在mapper接口的注解中，那么需要在创建SqlSessionFactoryBean
      的时候，需要setMapperLocations(Resource[] mapperLocations) 设置mapper.xml资源