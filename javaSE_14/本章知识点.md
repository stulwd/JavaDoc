- functionalInterface
- Stream.of创建Stream
    - IntStream.of(1,2,3,4)
- `stream.forEach(Consumer<? super T> action)`遍历stream
- 创建Stream方法：
    - 数组->Stream: Arrays.stream(数组)
    - Collections->Stream: collections.stream()
    - 基于supplier创建stream：`Stream.generate(Supplier<? extends T> s)`
- limit方法
- 返回文件的每一行Stream<String>: Files.lines(Path path)
- 按照正则split，返回Stream<String>: pattern.splitAsStream(string);
- 基本类型Stream：IntStream stream = Arrays.stream(new int[]{1, 2, 3, 4});
- stream.map(Function<? super T, ? extends R> mapper)
    - stream.map(String::trim)
    - stream.map(String::toLowerCase)
- stream.filter(Predicate<? super T> predicate)
- T strea m.reduce(T identity, BinaryOperator<T> accumulator)
- Optional<T> stream.reduce(BinaryOperator<T> accumulator)
- Stream转Collections：
    - 方法签名：stream.collect(Collector<? super T, A, R> collector)
    - collect(Collectors.toList())
    - collect(Collectors.toSet())
- Stream转数组：
    - stream.toArray(IntFunction<A[]> generator)
        - stream.toArray(String[]::new)
- Stream转map：
    - Map<String, String> map = stream.collect(Collectors.toMap(s -> s.split(":")[0], s -> s.split(":")[1]))
- 分组输出：
    - Map<String, List<String>> groups = f.stream().collect(Collectors.groupingBy(s -> s.substring(0, 1), Collectors.toList()));
        
- 排序: stream.sorted() 要求每个元素实现Comparable接口，或者传入一个Comparotor
- 去重: stream.distinct()
- 截取: skip和limit联合使用
- 合并: Stream.concat(stream1, stream2)
- 平铺: stream.flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)
    - 例如 Stream<List<Integer>> stream; stream.flatMap( list -> list.stream() ) 传入的function的入参是stream中每一个
      元素List<Integer>, 返回一个stream<Integer>, 最终把每次返回的stream<Integer>放到一个stream<Integer>中返回